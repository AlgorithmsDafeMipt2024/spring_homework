# Задача о наибольшей возрастающей последовательности (нвп)

**Наибольшая возрастающая подпоследовательность** (нвп) (англ. longest increasing subsequence, lis) строки x, длины n  — это последовательность x[i1]<x[i2]<⋯<x[ik]
 символов строки x таких, что i1<i2<⋯<ik,1⩽ij⩽n, причем k — наибольшее из возможных.

> ## Решение за время o(n^2)

Построим массив d, где d[i] — это длина наибольшей возрастающей подпоследовательности, оканчивающейся в элементе, с индексом i. Массив будем заполнять постепенно — сначала d[0], потом d[1] и т.д. Ответом на нашу задачу будет максимум из всех элементов массива d. Заполнение массива будет следующим: если d[i]=1, то искомая последовательность состоит только из числа a[i]. если d[i]>1, то перед числом a[i] в подпоследовательности стоит какое-то другое число. переберем его: это может быть любой элемент a[j](j=0...i−1), но такой, что a[j]<a[i]. Пусть на каком-то шаге нам надо посчитать очередное d[i]. Все элементы массива d до него уже посчитаны. значит наше d[i] мы можем посчитать следующим образом: d[i]=1+maxj=0..i−1d[j] при условии, что a[j]<a[i].

Пока что мы нашли лишь максимальную длину наибольшей возрастающей подпоследовательности, но саму ее мы вывести не можем. Для восстановления ответа заведем массив prev[0...n−1], где prev[i] будет означать индекс в массиве a[], при котором достигалось наибольшее значение d[i]. Для вывода ответа будем идти от элемента с максимальным значениям d[i] по его предкам.

## Псевдокод алгоритма
```c++
vector<int> findLIS(vector<int> a):
   int n = a.size                     //размер исходной последовательности
   int prev[0..n - 1]
   int d[0..n - 1]
 
   for i = 0 to n - 1
       d[i] = 1
       prev[i] = -1
       for j = 0 to i - 1
           if (a[j] < a[i] and d[j] + 1 > d[i])
               d[i] = d[j] + 1
               prev[i] = j
 
   pos = 0                            // индекс последнего элемента НВП
   length = d[0]                      // длина НВП
   for i = 0 to n - 1
       if d[i] > length
           pos = i
           length = d[i]
   
   // восстановление ответа
   vector<int> answer
   while pos != -1
       answer.push_back(a[pos])
       pos = prev[pos]
   reverse(answer)
 
   return answer    
```

> ## Решение за O(N log N)

Для более быстрого решения данной задачи построим следующую динамику: пусть d[i](i=0...n) — число, на которое оканчивается возрастающая последовательность длины i, а если таких чисел несколько — то наименьшее из них. Изначально мы предполагаем, что d[0]=−∞, а все остальные элементы d[i]=∞. Заметим два важных свойства этой динамики: d[i−1]⩽d[i], для всех i=1...nи каждый элемент a[i] обновляет максимум один элемент d[j]. Это означает, что при обработке очередного a[i], мы можем за O(logn) c помощью двоичного поиска в массиве d найти первое число, которое больше либо равно текущего a[i] и обновить его.

Для восстановления ответа будем поддерживать заполнение двух массивов: pos
и prev. В pos[i] будем хранить индекс элемента, на который заканчивается оптимальная подпоследовательность длины i, а в prev[i] — позицию предыдущего элемента для a[i].

Пример:


## Псевдокод алгоритма

```c++
vector<int> findLIS(vector<int> a):
   int n = a.size                     //размер исходной последовательности
   int d[0..n]
   int pos[0..n]
   int prev[0..n - 1]
   length = 0
   
   pos[0] = -1
   d[0] = -INF
   for i = 1 to n
       d[i] = INF
   for i = 0 to n - 1
       j = binary_search(d, a[i])
       if (d[j - 1] < a[i] and a[i] < d[j])
           d[j] = a[i]
           pos[j] = i
           prev[i] = pos[j - 1]
           length = max(length, j)
   
   // восстановление ответа
   vector<int> answer
   p = pos[length]
   while p != -1
       answer.push_back(a[p])
       p = prev[p]
   reverse(answer)
 
   return answer
```